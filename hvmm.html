<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Memory Manager</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2c2c2c;
            --text-color: #e0e0e0;
            --primary-color: #4CAF50;
            --ram-color-start: #87CEEB;
            --ram-color-end: #1E90FF;
            --swap-color-start: #FFB6C1;
            --swap-color-end: #FF69B4;
            --cache-color-start: #FFD700;
            --cache-color-end: #FFA500;
            --highlight-color: yellow;
            --victim-border-color: #FF6347;
            --border-radius: 8px;
            --box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            --border-color-light: #444;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px 10px;
        }

        .main-container {
            max-width: 1300px;
            margin: 0 auto;
            padding: 0 10px;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 25px;
        }

        .controls, .config, .stats {
            background: var(--surface-color);
            padding: 15px 20px;
            margin-bottom: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 12px;
            border: 1px solid var(--border-color-light);
        }

        .stats span {
            margin: 0 15px;
            font-size: 0.95em;
            color: var(--text-color);
        }
         .stats strong {
             color: var(--primary-color);
         }


        .config label, .controls label {
            margin-right: 5px;
            font-weight: 500;
        }

        .memory-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 30px;
            margin-top: 25px;
        }

        .memory-section {
            width: 280px;
            padding: 15px;
            background: var(--surface-color);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid var(--border-color-light);
            min-height: 200px;
        }

        .memory-section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 8px;
            width: 100%;
            text-align: center;
            font-size: 1.15em;
        }
         .memory-usage {
            font-size: 0.9em;
            color: #b0b0b0;
            margin-bottom: 15px;
         }

        .block {
            width: 90%;
            height: 35px;
            margin: 6px 0;
            text-align: center;
            line-height: 35px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease-in-out, transform 0.1s ease, border 0.2s linear;
            position: relative;
            border: 2px solid transparent;
            color: #111;
        }
         .block:hover {
             transform: scale(1.03);
             border-color: var(--highlight-color);
             box-shadow: 0 0 8px rgba(255, 255, 0, 0.5);
         }

         .block-victim-candidate {
             border: 2px dashed var(--victim-border-color) !important;
         }


        .in-ram { background: linear-gradient(45deg, var(--ram-color-start), var(--ram-color-end)); }
        .in-swap { background: linear-gradient(45deg, var(--swap-color-start), var(--swap-color-end)); }
        .in-cache { background: linear-gradient(45deg, var(--cache-color-start), var(--cache-color-end)); }

        .block-highlight {
            animation: highlight-pulse 0.7s 1;
        }
        .block-fade-out {
            animation: fade-out 0.5s forwards;
        }
        .block-fade-in {
            animation: fade-in 0.5s forwards;
        }

        @keyframes highlight-pulse {
            0%, 100% { box-shadow: 0 0 5px 2px var(--highlight-color); border-color: var(--highlight-color) !important; }
            50% { box-shadow: 0 0 15px 5px var(--highlight-color); border-color: var(--highlight-color) !important; }
        }
         @keyframes fade-out {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.8); }
         }
         @keyframes fade-in {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
         }


        button, select, input[type="number"], input[type="text"] {
            margin: 5px;
            padding: 10px 15px;
            background: #3a3a3a;
            color: var(--text-color);
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.95em;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        input[type="number"], input[type="text"] {
            width: 60px;
            cursor: text;
        }
         input[type="text"]#processIdInput {
             width: 90px;
         }

         input:focus {
             outline: none;
             border-color: var(--primary-color);
             box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
         }

        button:hover {
            background: #4f4f4f;
            border-color: #777;
        }
        button:active {
            background: #444;
            transform: translateY(1px);
        }


        #log {
            margin: 30px auto;
            padding: 15px;
            background: var(--surface-color);
            border-radius: var(--border-radius);
            height: 250px;
            overflow-y: auto;
            text-align: left;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            border: 1px solid var(--border-color-light);
            max-width: 90%;
            box-shadow: var(--box-shadow);
        }
        #log strong {
             color: var(--primary-color);
        }
        .log-entry {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px dashed #4f4f4f;
        }
         .log-entry:last-child {
             border-bottom: none;
         }
         .log-time { color: #aaa; margin-right: 10px; }
         .log-error { color: #FF69B4; font-weight: bold;}
         .log-success { color: #90EE90; }
         .log-info { color: #ADD8E6; }
         .log-warning { color: #FFA500; }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>Virtual Memory Manager</h1>

        <div class="config">
            <label for="ramSizeInput">RAM Size:</label>
            <input type="number" id="ramSizeInput" value="4" min="1" max="20" title="Number of pages RAM can hold (1-20)">
            <label for="swapSizeInput">Swap Size:</label>
            <input type="number" id="swapSizeInput" value="4" min="0" max="20" title="Number of pages Swap Space can hold (0-20)">
            <label for="cacheSizeInput">Cache Size:</label>
            <input type="number" id="cacheSizeInput" value="3" min="0" max="10" title="Number of entries Cache can hold (0-10)">
            <button onclick="applyConfig()" title="Apply new sizes and reset the simulation state">Apply Config & Reset</button>
        </div>

        <div class="controls">
            <label for="algorithm">Algorithm:</label>
            <select id="algorithm" title="Page replacement algorithm for RAM">
                <option value="fifo">FIFO</option>
                <option value="lru">LRU</option>
                <option value="lfu">LFU</option>
                <option value="lifo">LIFO</option>
                <option value="mru">MRU</option>
                <option value="random">Random</option>
            </select>
            <input type="text" id="processIdInput" placeholder="Process ID (e.g., P5)" title="Enter Process ID (P1-P20) or leave blank for random">
            <button onclick="allocateProcess()" title="Allocate the specified (or random available) process to RAM/Swap">Allocate Process</button>
            <button onclick="accessProcess()" title="Simulate accessing the specified (or random available) process">Access Process</button>
            <button onclick="manualAddToCache()" title="Manually add the specified process to Cache (must be in RAM)">Add to Cache</button>
            <button onclick="clearCache()" title="Remove all entries from the Cache">Clear Cache</button>
            <button onclick="resetSimulation()" title="Clear RAM, Swap, Cache, and Stats, keeping current sizes">Reset Simulation</button>
        </div>

         <div class="stats">
             <span>Total Accesses: <strong id="stats-total-accesses">0</strong></span>
             <span>Cache Hits: <strong id="stats-cache-hits">0</strong></span>
             <span>Page Faults: <strong id="stats-page-faults">0</strong></span>
             <span>Cache Hit Rate: <strong id="stats-cache-hit-rate">-%</strong></span>
             <span>Page Fault Rate: <strong id="stats-page-fault-rate">-%</strong></span>
         </div>

        <div class="memory-container">
            <div class="memory-section">
                <h3>Cache</h3>
                <div id="cache-usage" class="memory-usage">0/3 Used</div>
                <div id="cache"></div>
            </div>
            <div class="memory-section">
                <h3>Main Memory (RAM)</h3>
                <div id="ram-usage" class="memory-usage">0/4 Used</div>
                <div id="ram"></div>
            </div>
            <div class="memory-section">
                <h3>Swap Space</h3>
                <div id="swap-usage" class="memory-usage">0/4 Used</div>
                <div id="swap"></div>
            </div>
        </div>

        <div id="log"><strong>System Log:</strong><br></div>
    </div>

    <script>
        let ramSize = 4;
        let swapSize = 4;
        let cacheSize = 3;
        const MAX_PROCESS_ID = 20;

        let ram = [];
        let swap = [];
        let cache = new Map();

        let accessOrder = [];
        let accessFrequency = {};
        let ramAddTime = {};

        let totalAccesses = 0;
        let pageFaults = 0;
        let cacheHits = 0;

        let processPool = Array.from({ length: MAX_PROCESS_ID }, (_, i) => `P${i + 1}`);

        function initSimulation() {
            ram = [];
            swap = [];
            cache.clear();
            accessOrder = [];
            accessFrequency = {};
            ramAddTime = {};

            totalAccesses = 0;
            pageFaults = 0;
            cacheHits = 0;

            logEvent("Simulation initialized.", "info");
            updateDisplay();
        }

        function applyConfig() {
             const newRamSize = parseInt(document.getElementById('ramSizeInput').value);
             const newSwapSize = parseInt(document.getElementById('swapSizeInput').value);
             const newCacheSize = parseInt(document.getElementById('cacheSizeInput').value);

             if (isNaN(newRamSize) || newRamSize < 1 || newRamSize > 20 ||
                 isNaN(newSwapSize) || newSwapSize < 0 || newSwapSize > 20 ||
                 isNaN(newCacheSize) || newCacheSize < 0 || newCacheSize > 10) {
                  logEvent("Invalid size configuration. Please use valid numbers within limits.", "error");
                  document.getElementById('ramSizeInput').value = ramSize;
                  document.getElementById('swapSizeInput').value = swapSize;
                  document.getElementById('cacheSizeInput').value = cacheSize;
                  return;
             }

             ramSize = newRamSize;
             swapSize = newSwapSize;
             cacheSize = newCacheSize;

             logEvent(`Configuration updated: RAM=${ramSize}, Swap=${swapSize}, Cache=${cacheSize}. Resetting simulation.`, "info");
             initSimulation();
        }

        function resetSimulation() {
            logEvent("Simulation reset requested.", "info");
            initSimulation();
        }


        function getProcessIdInput(required = false) {
            const inputElement = document.getElementById('processIdInput');
            let processId = inputElement.value.trim().toUpperCase();
            let usedFallback = false;

            if (!processId) {
                if (required) {
                    logEvent(`Valid Process ID required in the input field for this action.`, "warning");
                    inputElement.focus();
                    return null;
                } else {
                    usedFallback = true;
                    const allocated = new Set([...ram, ...swap, ...cache.keys()]);
                    const available = processPool.filter(p => !allocated.has(p));
                    if (available.length === 0) {
                        processId = processPool[Math.floor(Math.random() * processPool.length)];
                        logEvent(`Input empty, and no unallocated processes available. Using random existing process: ${processId}`, "warning");
                    } else {
                        processId = available[Math.floor(Math.random() * available.length)];
                        logEvent(`Input empty. Using random available process: ${processId}`, "info");
                    }
                    inputElement.value = processId;
                }
            } else if (!/^P\d+$/.test(processId)) {
                logEvent(`Invalid Process ID format: "${processId}". Use format P# (e.g., P5).`, "error");
                inputElement.focus();
                return null;
            } else {
                const num = parseInt(processId.substring(1));
                if (num < 1 || num > MAX_PROCESS_ID) {
                    logEvent(`Process ID ${processId} out of range (P1-P${MAX_PROCESS_ID}).`, "error");
                    inputElement.focus();
                    return null;
                }
            }

            return processId;
        }


        function allocateProcess() {
            const processId = getProcessIdInput(false);
            if (!processId) return;

            const inputElement = document.getElementById('processIdInput');

            if (ram.includes(processId) || swap.includes(processId) || cache.has(processId)) {
                logEvent(`Process ${processId} is already in memory (RAM, Swap, or Cache). Cannot allocate again.`, "warning");
                highlightExistingBlock(processId);
                inputElement.value = '';
                return;
            }

            logEvent(`Attempting to allocate Process ${processId}...`, "info");

            if (ram.length < ramSize) {
                ram.push(processId);
                const now = Date.now();
                accessOrder.push(processId);
                accessFrequency[processId] = 1;
                ramAddTime[processId] = now;

                logEvent(`Process ${processId} allocated directly to RAM.`, "success");
                updateDisplay();
                highlightBlock(processId, 'ram', 'block-fade-in');
            } else {
                logEvent(`RAM full. Evicting page using ${document.getElementById("algorithm").value.toUpperCase()}...`, "warning");
                const evictedProcessId = evictPage();

                if (evictedProcessId) {
                    if (swap.length < swapSize) {
                        swap.push(evictedProcessId);
                        logEvent(`Process ${evictedProcessId} evicted from RAM and moved to Swap.`, "info");
                    } else {
                        logEvent(`Process ${evictedProcessId} evicted from RAM. Swap full, page discarded.`, "warning");
                    }
                    cleanUpTrackingData(evictedProcessId);

                    ram.push(processId);
                    const now = Date.now();
                    accessOrder.push(processId);
                    accessFrequency[processId] = 1;
                    ramAddTime[processId] = now;

                    logEvent(`Process ${processId} allocated to RAM after eviction.`, "success");
                    updateDisplay();
                    highlightBlock(processId, 'ram', 'block-fade-in');
                    if (swap.includes(evictedProcessId)) {
                        setTimeout(() => highlightBlock(evictedProcessId, 'swap', 'block-highlight'), 150);
                    }
                } else {
                     logEvent(`Allocation of ${processId} failed because eviction failed.`, "error");
                     return;
                }
            }
            inputElement.value = '';
        }

        function accessProcess() {
            const processId = getProcessIdInput(false);
            if (!processId) return;

            const inputElement = document.getElementById('processIdInput');
            logEvent(`Attempting to access Process ${processId}...`, "info");
            const now = Date.now();
            totalAccesses++;

            if (cache.has(processId)) {
                cacheHits++;
                logEvent(`Cache Hit! Process ${processId} found in Cache.`, "success");
                cache.get(processId).lastAccess = now;
                highlightBlock(processId, 'cache', 'block-highlight');
                updateDisplay();
                inputElement.value = '';
                return;
            }

            logEvent(`Cache Miss for ${processId}. Checking RAM...`, "info");

            if (ram.includes(processId)) {
                logEvent(`RAM Hit! Process ${processId} found in RAM.`, "success");
                updateUsageTracking(processId, now);
                addToCache(processId, now);
                highlightBlock(processId, 'ram', 'block-highlight');
                updateDisplay();
                inputElement.value = '';
                return;
            }

            logEvent(`RAM Miss for ${processId}. Checking Swap...`, "info");

            if (swap.includes(processId)) {
                pageFaults++;
                logEvent(`Page Fault! Process ${processId} found in Swap Space. Loading into RAM...`, "warning");
                handlePageFault(processId, now);
                inputElement.value = '';
                return;
            }

            pageFaults++;
            logEvent(`Page Fault & Not Found! Process ${processId} not in Cache, RAM, or Swap.`, "error");
            updateDisplay();
            inputElement.value = '';
        }


        function manualAddToCache() {
            const processId = getProcessIdInput(true);
            if (!processId) return;

            const inputElement = document.getElementById('processIdInput');

            if (cacheSize <= 0) {
                logEvent("Cache is disabled (size 0). Cannot add.", "warning");
                inputElement.value = ''; return;
            }
            if (cache.has(processId)) {
                 logEvent(`Process ${processId} is already in the cache.`, "info");
                 highlightBlock(processId, 'cache', 'block-highlight');
                 inputElement.value = ''; return;
            }

            if (ram.includes(processId)) {
                logEvent(`Process ${processId} found in RAM. Attempting to add to cache manually...`, "info");
                const now = Date.now();
                addToCache(processId, now);

                if (cache.has(processId)) {
                    logEvent(`Process ${processId} successfully added to cache manually.`, "success");
                    updateDisplay();
                    highlightBlock(processId, 'cache', 'block-fade-in');
                } else {
                    logEvent(`Failed to add ${processId} to cache (possibly cache size is 0 or internal error).`, "error");
                    updateDisplay();
                }
            } else {
                logEvent(`Process ${processId} must be in RAM to be added to the cache manually.`, "warning");
                highlightExistingBlock(processId);
            }
            inputElement.value = '';
        }

        function clearCache() {
            if (cache.size === 0) {
                 logEvent("Cache is already empty.", "info");
                 return;
            }
            cache.clear();
            logEvent("Cache cleared manually.", "success");
            updateDisplay();
        }


        function handlePageFault(processId, accessTime) {
            const swapIndex = swap.indexOf(processId);
            if (swapIndex > -1) {
                 swap.splice(swapIndex, 1);
                 logEvent(`Process ${processId} removed from Swap.`, "info");
            }

            let evictedProcessId = null;
            if (ram.length >= ramSize) {
                logEvent(`RAM full. Evicting page using ${document.getElementById("algorithm").value.toUpperCase()}...`, "warning");
                evictedProcessId = evictPage();

                if (evictedProcessId) {
                    if (swap.length < swapSize) {
                        swap.push(evictedProcessId);
                        logEvent(`Process ${evictedProcessId} evicted from RAM and moved to Swap.`, "info");
                    } else {
                        logEvent(`Process ${evictedProcessId} evicted from RAM. Swap full, page discarded.`, "warning");
                    }
                    cleanUpTrackingData(evictedProcessId);
                } else {
                    logEvent(`Page fault for ${processId} failed: Eviction from RAM failed. Cannot load.`, "error");
                    logEvent(`Process ${processId} load failed and is discarded.`, "error");
                    updateDisplay();
                    return;
                }
            }

            ram.push(processId);
            ramAddTime[processId] = accessTime;
            accessFrequency[processId] = 1;
            accessOrder = accessOrder.filter(p => p !== processId);
            accessOrder.push(processId);

            logEvent(`Process ${processId} loaded into RAM.`, "success");

            addToCache(processId, accessTime);

            updateDisplay();
            highlightBlock(processId, 'ram', 'block-fade-in');
            if (evictedProcessId && swap.includes(evictedProcessId)) {
                 setTimeout(() => highlightBlock(evictedProcessId, 'swap', 'block-highlight'), 150);
            }
        }


        function peekEvictPage() {
            if (ram.length < ramSize || ram.length === 0) return null;

            const algorithm = document.getElementById("algorithm").value;
            let victim = null;
            let validRamProcesses = ram.filter(p => p);

            if(validRamProcesses.length === 0) return null;

            let candidate = validRamProcesses[0];

            switch (algorithm) {
                case "fifo":
                     victim = validRamProcesses.reduce((oldest, p) =>
                         ((ramAddTime[p] || 0) < (ramAddTime[oldest] || 0) ? p : oldest),
                         candidate);
                    break;
                case "lru":
                     for (const p of accessOrder) {
                         if (validRamProcesses.includes(p)) { victim = p; break; }
                     }
                     if (!victim) victim = candidate;
                    break;
                case "lfu":
                    victim = validRamProcesses.reduce((leastFreq, p) => {
                        const freqP = accessFrequency[p] || 0;
                        const freqLeast = accessFrequency[leastFreq] || 0;
                        if (freqP < freqLeast) return p;
                        if (freqP === freqLeast) return ((ramAddTime[p] || 0) < (ramAddTime[leastFreq] || 0) ? p : leastFreq);
                        return leastFreq;
                    }, candidate);
                    break;
                case "lifo":
                     victim = validRamProcesses.reduce((newest, p) =>
                         ((ramAddTime[p] || 0) > (ramAddTime[newest] || 0) ? p : newest),
                         candidate);
                    break;
                case "mru":
                     for (let i = accessOrder.length - 1; i >= 0; i--) {
                        if (validRamProcesses.includes(accessOrder[i])) { victim = accessOrder[i]; break; }
                     }
                     if (!victim) victim = validRamProcesses[validRamProcesses.length - 1];
                    break;
                case "random":
                default:
                    victim = null;
                    break;
            }
            return victim;
        }


        function evictPage() {
            if (ram.length === 0) {
                logEvent("Attempted to evict from empty RAM.", "error");
                return null;
            }

            const algorithm = document.getElementById("algorithm").value;
            let victim = null;
            let validRamProcesses = ram.filter(p => p);

            if(validRamProcesses.length === 0) {
                 logEvent("RAM contains no valid processes to evict.", "error");
                 return null;
            }

            let candidate = validRamProcesses[0];

            switch (algorithm) {
                case "fifo":
                     victim = validRamProcesses.reduce((oldest, p) =>
                         ((ramAddTime[p] || 0) < (ramAddTime[oldest] || 0) ? p : oldest),
                         candidate);
                    break;
                case "lru":
                     for (const p of accessOrder) {
                         if (validRamProcesses.includes(p)) { victim = p; break; }
                     }
                     if (!victim) victim = candidate;
                    break;
                case "lfu":
                    victim = validRamProcesses.reduce((leastFreq, p) => {
                        const freqP = accessFrequency[p] || 0;
                        const freqLeast = accessFrequency[leastFreq] || 0;
                        if (freqP < freqLeast) return p;
                        if (freqP === freqLeast) return ((ramAddTime[p] || 0) < (ramAddTime[leastFreq] || 0) ? p : leastFreq);
                        return leastFreq;
                    }, candidate);
                    break;
                case "lifo":
                     victim = validRamProcesses.reduce((newest, p) =>
                         ((ramAddTime[p] || 0) > (ramAddTime[newest] || 0) ? p : newest),
                         candidate);
                    break;
                case "mru":
                     for (let i = accessOrder.length - 1; i >= 0; i--) {
                        if (validRamProcesses.includes(accessOrder[i])) { victim = accessOrder[i]; break; }
                     }
                     if (!victim) victim = validRamProcesses[validRamProcesses.length - 1];
                    break;
                case "random":
                default:
                    victim = validRamProcesses[Math.floor(Math.random() * validRamProcesses.length)];
                    break;
            }


            if (victim) {
                logEvent(`Eviction choice (${algorithm.toUpperCase()}): Process ${victim}`, "info");
                const ramIndex = ram.indexOf(victim);
                if (ramIndex > -1) {
                     ram.splice(ramIndex, 1);
                } else {
                     logEvent(`Critical Error: Chosen victim ${victim} not found in RAM array during removal!`, "error");
                     return null;
                }
            } else {
                 logEvent(`Eviction failed: No victim could be determined for algorithm ${algorithm.toUpperCase()}.`, "error");
            }
            return victim;
        }


        function cleanUpTrackingData(processId) {
             accessOrder = accessOrder.filter(p => p !== processId);
             delete accessFrequency[processId];
             delete ramAddTime[processId];
        }

        function updateUsageTracking(processId, accessTime) {
             accessOrder = accessOrder.filter(p => p !== processId);
             accessOrder.push(processId);
            accessFrequency[processId] = (accessFrequency[processId] || 0) + 1;
        }

        function addToCache(processId, accessTime) {
            if (cacheSize <= 0) return;

            let existingEntry = cache.get(processId);
            if (existingEntry) {
                existingEntry.lastAccess = accessTime;
                return;
            }

            if (cache.size >= cacheSize) {
                let lruProcess = null;
                let oldestTime = Infinity;
                for (const [key, value] of cache.entries()) {
                    if (value.lastAccess < oldestTime) {
                        oldestTime = value.lastAccess;
                        lruProcess = key;
                    }
                }
                if (lruProcess) {
                    cache.delete(lruProcess);
                    logEvent(`Cache full. Removed ${lruProcess} (LRU) from cache.`, "warning");
                } else if (cache.size > 0) {
                     logEvent(`Cache full but failed to find LRU entry to evict.`, "error");
                     return;
                }
            }

             if(cache.size < cacheSize){
                cache.set(processId, { data: `Data for ${processId}`, lastAccess: accessTime });
                logEvent(`Process ${processId} added to cache.`, "success");
             }
        }


        function updateDisplay() {
            const ramDiv = document.getElementById("ram");
            const swapDiv = document.getElementById("swap");
            const cacheDiv = document.getElementById("cache");

            const predictedVictim = peekEvictPage();

            ramDiv.innerHTML = ram.map(p => createBlockHTML(p, 'ram', p === predictedVictim)).join("");
            swapDiv.innerHTML = swap.map(p => createBlockHTML(p, 'swap')).join("");

            const sortedCacheEntries = [...cache.entries()].sort(([,a], [,b]) => a.lastAccess - b.lastAccess);
            cacheDiv.innerHTML = sortedCacheEntries.map(([p]) => createBlockHTML(p, 'cache')).join("");

            document.getElementById('ram-usage').textContent = `${ram.length}/${ramSize} Used`;
            document.getElementById('swap-usage').textContent = `${swap.length}/${swapSize} Used`;
            document.getElementById('cache-usage').textContent = `${cache.size}/${cacheSize} Used`;

            document.getElementById('stats-total-accesses').textContent = totalAccesses;
            document.getElementById('stats-cache-hits').textContent = cacheHits;
            document.getElementById('stats-page-faults').textContent = pageFaults;
            const cacheHitRate = totalAccesses > 0 ? ((cacheHits / totalAccesses) * 100).toFixed(1) : 0;
            const pageFaultRate = totalAccesses > 0 ? ((pageFaults / totalAccesses) * 100).toFixed(1) : 0;
            document.getElementById('stats-cache-hit-rate').textContent = `${totalAccesses > 0 ? cacheHitRate : '-'}%`;
            document.getElementById('stats-page-fault-rate').textContent = `${totalAccesses > 0 ? pageFaultRate : '-'}%`;


             document.querySelectorAll('.block').forEach(block => {
                block.removeEventListener('click', handleBlockClick);
                block.addEventListener('click', handleBlockClick);
            });
        }

         function handleBlockClick(event) {
             const processId = event.target.getAttribute('data-process-id');
             if (processId) {
                document.getElementById('processIdInput').value = processId;
                accessProcess();
             }
         }

         function createBlockHTML(processId, type, isVictimCandidate = false) {
             let className = 'block';
             if (type === 'ram') className += ' in-ram';
             else if (type === 'swap') className += ' in-swap';
             else if (type === 'cache') className += ' in-cache';

             if (isVictimCandidate) {
                 className += ' block-victim-candidate';
             }

             const freq = accessFrequency[processId] || '-';
             const addTime = ramAddTime[processId] ? new Date(ramAddTime[processId]).toLocaleTimeString() : '-';
             let title = `Process ${processId}`;
             if (type === 'ram') {
                title += ` | Freq: ${freq} | Added: ${addTime}`;
                if (isVictimCandidate) title += ` | Candidate for next eviction!`;
             } else if (type === 'cache') {
                 const cacheEntry = cache.get(processId);
                 const accessTime = cacheEntry ? new Date(cacheEntry.lastAccess).toLocaleTimeString() : '-';
                 title += ` | Last Access: ${accessTime}`;
             }

             return `<div class="${className}" id="block-${type}-${processId}" data-process-id="${processId}" title="${title}">${processId}</div>`;
         }

        function logEvent(message, type = "info") {
            const logDiv = document.getElementById("log");
            if (!logDiv) { console.error("Log div not found!"); return; }
            const time = new Date().toLocaleTimeString();
            let typeClass = 'log-info';
            if (type === 'success') typeClass = 'log-success';
            else if (type === 'warning') typeClass = 'log-warning';
            else if (type === 'error') typeClass = 'log-error';

            const entryDiv = document.createElement('div');
            entryDiv.className = 'log-entry';
            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = time;
            const messageSpan = document.createElement('span');
            messageSpan.className = typeClass;
            messageSpan.textContent = message;

            entryDiv.appendChild(timeSpan);
            entryDiv.appendChild(messageSpan);

            const placeholder = logDiv.querySelector('strong');
            if (placeholder && logDiv.children.length === 1 && logDiv.firstChild === placeholder) {
                 logDiv.innerHTML = '';
            }

            logDiv.appendChild(entryDiv);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function highlightBlock(processId, location, animationClass = 'block-highlight') {
            const blockId = `block-${location}-${processId}`;
            const blockElement = document.getElementById(blockId);
            if (blockElement) {
                const duration = animationClass.includes('fade') ? 500 : 700;
                blockElement.classList.remove('block-victim-candidate');
                blockElement.classList.remove('block-highlight', 'block-fade-in', 'block-fade-out');
                void blockElement.offsetWidth;

                blockElement.classList.add(animationClass);

                setTimeout(() => {
                     if (blockElement) {
                        blockElement.classList.remove(animationClass);
                        const currentVictim = peekEvictPage();
                        if (location === 'ram' && processId === currentVictim) {
                            blockElement.classList.add('block-victim-candidate');
                        }
                     }
                 }, duration);
            }
        }

         function highlightExistingBlock(processId) {
             if (cache.has(processId)) highlightBlock(processId, 'cache');
             else if (ram.includes(processId)) highlightBlock(processId, 'ram');
             else if (swap.includes(processId)) highlightBlock(processId, 'swap');
         }


        document.addEventListener('DOMContentLoaded', () => {
             document.getElementById('ramSizeInput').value = ramSize;
             document.getElementById('swapSizeInput').value = swapSize;
             document.getElementById('cacheSizeInput').value = cacheSize;
             initSimulation();
         });

    </script>
</body>
</html>
